# SPDX-FileCopyrightText: 2022 SAP SE or an SAP affiliate company and Gardener contributors
#
# SPDX-License-Identifier: Apache-2.0

import logging
import os
import subprocess
import tempfile
import typing

import ci.log
import ci.util
import oci.model as om


cosign_password_env_var = 'COSIGN_PASSWORD'
cosign_private_key_filename = 'import-cosign.key'
cosign_public_key_filename = 'import-cosign.pub'


ci.log.configure_default_logging()
logger = logging.getLogger(__name__)


def _prepare_env(env: dict) -> dict:
    '''
    prepare an environment for running cosign commands
    '''
    env_copy = dict(env)

    path_env_var = 'PATH'
    if path_env_var not in env_copy:
        env_copy[path_env_var] = os.getenv(path_env_var)

    if cosign_password_env_var not in env_copy:
        # set special env variable to disable password prompt from cosign
        env_copy[cosign_password_env_var] = ''

    return env_copy


def generate_cosign_signature(
    img_ref: str,
    key_file: str,
    env = {},
) -> str:
    '''
    generates and uploads the cosign signature for a target image ref
    the target image must be referenced via digest, as cosign generates the signature ref based on the target image digest
    returns the cosign signature ref
    '''
    parsed_img_ref = om.OciImageReference.to_image_ref(img_ref)
    if not parsed_img_ref.has_digest_tag:
        ValueError('only images that are referenced via a digest are allowed')

    cmd = f'cosign sign --key {key_file} {img_ref}'
    env = _prepare_env(env=env)
    logger.info(f'run cmd \'{cmd}\'')
    subprocess.run(cmd.split(' '), check=True, env=env)

    parsed_digest = parsed_img_ref.parsed_digest_tag
    alg, val = parsed_digest
    cosign_sig_ref = f'{parsed_img_ref.ref_without_tag}:{alg}-{val}.sig'

    return cosign_sig_ref


def import_key_pair_from_file(
    private_key_file: str,
    tgt_dir: str,
    env = {},
) -> typing.Tuple[str, str]:
    '''
    import a PEM-encoded RSA or EC private key via cosign from the file system
    returns the path to the private and public key files which are generated by cosign in tgt_dir
    '''
    abs_private_key_file = os.path.abspath(private_key_file)

    cmd = f'cosign import-key-pair --key {abs_private_key_file}'
    env = _prepare_env(env=env)
    logger.info(f'run cmd \'{cmd}\'')
    subprocess.run(cmd.split(' '), check=True, cwd=tgt_dir, env=env)

    cosign_private_key_file = os.path.join(tgt_dir, cosign_private_key_filename)
    cosign_public_key_file = os.path.join(tgt_dir, cosign_public_key_filename)

    return (cosign_private_key_file, cosign_public_key_file)


def import_key_pair_from_memory(
    private_key: str,
    tgt_dir: str,
    env = {},
) -> typing.Tuple[str, str]:
    '''
    import a PEM-encoded RSA or EC private key via cosign from memory
    returns the path to the private and public key files which are generated by cosign in tgt_dir
    '''
    with tempfile.NamedTemporaryFile() as f:
        f.write(private_key.encode())
        f.seek(0)
        return import_key_pair_from_file(
            private_key_file=f.name,
            tgt_dir=tgt_dir,
            env=env,
        )
